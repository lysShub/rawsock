package raw

import (
	"fmt"
	"net/netip"

	"gvisor.dev/gvisor/pkg/buffer"
	"gvisor.dev/gvisor/pkg/tcpip"
	"gvisor.dev/gvisor/pkg/tcpip/header"
	"gvisor.dev/gvisor/pkg/tcpip/link/channel"
	"gvisor.dev/gvisor/pkg/tcpip/network/ipv4"
	"gvisor.dev/gvisor/pkg/tcpip/network/ipv6"
	"gvisor.dev/gvisor/pkg/tcpip/stack"
	"gvisor.dev/gvisor/pkg/tcpip/transport/icmp"
	"gvisor.dev/gvisor/pkg/tcpip/transport/tcp"
	"gvisor.dev/gvisor/pkg/tcpip/transport/udp"
)

type tcpStack struct {
	ep    *channel.Endpoint
	stack *stack.Stack

	incomingPacket chan *buffer.View
	mtu            int
}

func NewStack(locAddr netip.Addr) (*tcpStack, error) {

	const NICID = 19986

	opts := stack.Options{
		NetworkProtocols:   []stack.NetworkProtocolFactory{ipv4.NewProtocol, ipv6.NewProtocol},
		TransportProtocols: []stack.TransportProtocolFactory{tcp.NewProtocol, udp.NewProtocol, icmp.NewProtocol6, icmp.NewProtocol4},
		HandleLocal:        true,
	}
	s := &tcpStack{
		ep:    channel.New(64, 1500, ""),
		stack: stack.New(opts),
	}
	s.ep.AddNotify(s)

	if err := s.stack.CreateNIC(NICID, s.ep); err != nil {
		return nil, fmt.Errorf("CreateNIC: %v", err)
	}

	var ipVer tcpip.NetworkProtocolNumber
	if locAddr.Is4() {
		ipVer = ipv4.ProtocolNumber
	} else {
		ipVer = ipv6.ProtocolNumber
	}
	err := s.stack.AddProtocolAddress(NICID, tcpip.ProtocolAddress{
		Protocol:          ipVer,
		AddressWithPrefix: tcpip.AddrFromSlice(locAddr.AsSlice()).WithPrefix(),
	}, stack.AddressProperties{})
	if err != nil {
		return nil, fmt.Errorf("AddProtocolAddress(%v): %v", locAddr, err)
	}
	s.stack.AddRoute(tcpip.Route{Destination: header.IPv4EmptySubnet, NIC: NICID})
	s.stack.AddRoute(tcpip.Route{Destination: header.IPv6EmptySubnet, NIC: NICID})

	return s, nil
}

func (s *tcpStack) WriteNotify() {
	pkt := s.ep.Read()
	if pkt.IsNil() {
		return
	}

	view := pkt.ToView()
	pkt.DecRef()

	s.incomingPacket <- view
}
