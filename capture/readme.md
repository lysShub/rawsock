Deprecated: plan A 实现不好，plan B 的假设不成立(使用eth raw socket)


测试tun/tap 设备处理全局数据包：
（不是传统的全局代理：将所有数据在代理服务器上重放）

有网卡eth0  172.23.193.179/24 

Plan A:
1. 创建tun/tap设备，有地址 10.0.0.1/24
2. 将最高优先级的缺省路由改为 10.0.0.1/24
3. 程序从tup/tap读取数据包，判断是否处理，如果不需要处理，则将源地址改为eth0, 同时添加此IP的指定路由

存在的问题： 1. 路由表条目过多， 2. 无法及时删除临时指定路由 3.不能代理连接中的某些数据包


Plan B:
1. 创建tun/tap设备，有地址 10.0.0.1/24
2. 将最高优先级的缺省路由改为 10.0.0.1/24
3.  相对于Plan A，不需要添加指定路由，而是对不需要处理的数据包直接更改src mac/ip address 为eth0, 然后再写入tap设备
    （前提要求写入的eth数据包是理想的：从eth0出去了）




本质是为了能处理到所有数据包，并且能让不需要处理的数据包通过默认的设备发送出去。
比如，可以参考[android vpn servive](https://github.com/asdzheng/vpnservices)的实现  

a.  应用程序使用socket，将相应的数据包发送到真实的网络设备上。一般移动设备只有无线网卡，因此是发送到真实的WiFi设备上；  

b.  Android系统通过iptables，使用NAT，将所有的数据包转发到TUN虚拟网络设备上去，端口是tun0；

c.  VPN程序通过打开/dev/tun设备，并读取该设备上的数据，可以获得所有转发到TUN虚拟网络设备上的IP包。因为设备上的所有IP包都会被NAT转成原地址是tun0端口发送的，所以也就是说你的VPN程序可以获得进出该设备的几乎所有的数据（也有例外，不是全部，比如回环数据就无法获得）;  

d.  VPN数据可以做一些处理，然后将处理过后的数据包，通过真实的网络设备发送出去。为了防止发送的数据包再被转到TUN虚拟网络设备上，VPN程序所使用的socket必须**先**被明确绑定到真实的网络设备上去。(设置的iptables规则不好作用于创建好的socket)  



