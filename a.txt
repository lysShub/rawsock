
// 通过iptables实现
type RawTCP struct {
	loc, dst *net.TCPAddr
	its      *iptables.IPTables
	bindFd   int

	raw *net.IPConn
}

func DialRawTCP(laddr, dstAddr *net.TCPAddr) (r *RawTCP, err error) {
	r = &RawTCP{}

	if laddr == nil {
		laddr = &net.TCPAddr{}
	}
	if r.raw, err = net.DialIP("ip:tcp",
		&net.IPAddr{IP: laddr.IP, Zone: laddr.Zone},
		&net.IPAddr{IP: dstAddr.IP, Zone: laddr.Zone},
	); err != nil {
		return nil, err
	} else {
		loc := r.raw.LocalAddr().(*net.IPAddr)
		r.loc = &net.TCPAddr{IP: loc.IP, Zone: loc.Zone}
		dst := r.raw.RemoteAddr().(*net.IPAddr)
		r.dst = &net.TCPAddr{IP: dst.IP, Zone: dst.Zone}
	}

	if err = r.bindLocal(); err != nil {
		r.raw.Close()
		return nil, err
	}

	if err = r.setBpf(); err != nil {
		r.raw.Close()
		unix.Close(r.bindFd)
		return nil, err
	}

	return r, nil
}

// bindLocal for EADDRINUSE
func (r *RawTCP) bindLocal() error {
	nip, ok := netip.AddrFromSlice(r.loc.IP)
	if !ok {
		return fmt.Errorf("invalid local ip address %s", r.loc.IP)
	}

	var err error

	if nip.Is4() {
		r.bindFd, err = unix.Socket(unix.AF_INET, unix.SOCK_STREAM, unix.IPPROTO_TCP)
		if err != nil {
			return err
		}

		err = unix.Bind(r.bindFd, &unix.SockaddrInet4{Addr: [4]byte(r.loc.IP), Port: r.loc.Port})
		if err != nil {
			return err
		} else if r.loc.Port == 0 {
			sa, err := unix.Getsockname(r.bindFd)
			if err != nil {
				unix.Close(r.bindFd)
				return err
			}
			r.loc.Port = sa.(*unix.SockaddrInet4).Port
		}
	} else {
		r.bindFd, err = unix.Socket(unix.AF_INET6, unix.SOCK_STREAM, unix.IPPROTO_TCP)
		if err != nil {
			return err
		}

		zoneIdx := 0
		if r.loc.Zone != "" {
			ifi, err := net.InterfaceByName(r.loc.Zone)
			if err != nil {
				return err
			}
			zoneIdx = ifi.Index
		}
		err = unix.Bind(r.bindFd, &unix.SockaddrInet6{Addr: nip.As16(), Port: r.loc.Port, ZoneId: uint32(zoneIdx)})
		if err != nil {
			return err
		} else if r.loc.Port == 0 {
			sa, err := unix.Getsockname(r.bindFd)
			if err != nil {
				unix.Close(r.bindFd)
				return err
			}
			r.loc.Port = sa.(*unix.SockaddrInet6).Port
		}
	}

	return nil
}

func (r *RawTCP) setBpf() error {

	{ // for raw

		raw, err := bpf.Assemble([]bpf.Instruction{
			bpf.LoadExtension{Num: bpf.ExtPayloadOffset},

			bpf.LoadAbsolute{Off: 0, Size: 2},
			bpf.JumpIf{Cond: bpf.JumpEqual, Val: uint32(r.dst.Port), SkipTrue: 1},
			bpf.RetConstant{Val: 0},

			bpf.LoadAbsolute{Off: 2, Size: 2},
			bpf.JumpIf{Cond: bpf.JumpEqual, Val: uint32(r.loc.Port), SkipTrue: 1},
			bpf.RetConstant{Val: 0},

			bpf.RetConstant{Val: 0xffff},
		})
		if err != nil {
			return err
		}
		prog := unix.SockFprog{
			Len:    uint16(len(raw)),
			Filter: (*unix.SockFilter)(unsafe.Pointer(&raw[0])),
		}
		b := (*[unix.SizeofSockFprog]byte)(unsafe.Pointer(&prog))[:unix.SizeofSockFprog]

		r, err := r.raw.SyscallConn()
		if err != nil {
			return err
		}
		e := r.Control(func(fd uintptr) {
			err = unix.SetsockoptString(int(fd), unix.SOL_SOCKET, unix.SO_ATTACH_FILTER, string(b))
		})
		if err != nil {
			return err
		} else if e != nil {
			return err
		}
	}

	{ // for bindFd
		raw, err := bpf.Assemble([]bpf.Instruction{bpf.RetConstant{Val: 0}})
		if err != nil {
			return err
		}
		prog := unix.SockFprog{
			Len:    uint16(len(raw)),
			Filter: (*unix.SockFilter)(unsafe.Pointer(&raw[0])),
		}
		b := (*[unix.SizeofSockFprog]byte)(unsafe.Pointer(&prog))[:unix.SizeofSockFprog]
		err = unix.SetsockoptString(r.bindFd, unix.SOL_SOCKET, unix.SO_ATTACH_FILTER, string(b))
		if err != nil {
			return err
		}
	}

	return nil
}

// todo: 不用iptables，用bpf直接过滤掉
func (r *RawTCP) setIptables() error {
	var err error
	r.its, err = iptables.New(iptables.IPFamily(iptables.ProtocolIPv4))
	if err != nil {
		return err
	}

	// iptables -A INPUT -p tcp --dport 80 -j DROP

	err = r.its.Append("filter", "INPUT", "-p", "tcp", "--dport", strconv.Itoa(r.loc.Port), "-j", "DROP")
	if err != nil {
		return err
	}

	// err = r.its.Append("filter", "OUTPUT", "-p", "tcp", "--sport", strconv.Itoa(r.dst.Port), "-j", "DROP")
	// if err != nil {
	// 	return err
	// }

	return err
}

func (r *RawTCP) Read(b []byte) (n int, err error) {
	return r.raw.Read(b)
}
func (r *RawTCP) Write(b []byte) (n int, err error) {
	return r.raw.Write(b)
}

func (r *RawTCP) Close() (err error) {
	if e := r.raw.Close(); e != nil {
		err = e
	}
	if e := r.its.DeleteAll(); err != nil {
		err = e
	}
	if e := unix.Close(r.bindFd); err != nil {
		err = e
	}

	return err
}
func (r *RawTCP) LocalAddr() net.Addr                    { return r.loc }
func (r *RawTCP) RemoteAddr() net.Addr                   { return r.dst }
func (r *RawTCP) SetDeadline(t time.Time) error          { return r.raw.SetDeadline(t) }
func (r *RawTCP) SetReadDeadline(t time.Time) error      { return r.raw.SetReadDeadline(t) }
func (r *RawTCP) SetWriteDeadline(t time.Time) error     { return r.raw.SetWriteDeadline(t) }
func (r *RawTCP) SysacallConn() (syscall.RawConn, error) { return r.raw.SyscallConn() }

// type RawListener struct {
// 	*RawTCP
// }

// func ListeRawTCP(locAddr *net.TCPAddr) (l *RawListener, err error) {
// 	r := &RawTCP{}

// 	if locAddr == nil {
// 		locAddr = &net.TCPAddr{}
// 	}
// 	if r.raw, err = net.DialIP("ip:tcp",
// 		&net.IPAddr{IP: locAddr.IP, Zone: locAddr.Zone},
// 	); err != nil {
// 		return nil, err
// 	} else {
// 		loc := r.raw.LocalAddr().(*net.IPAddr)
// 		r.loc = &net.TCPAddr{IP: loc.IP, Zone: loc.Zone}
// 		dst := r.raw.RemoteAddr().(*net.IPAddr)
// 		r.dst = &net.TCPAddr{IP: dst.IP, Zone: dst.Zone}
// 	}

// 	if err = r.bindLocal(); err != nil {
// 		r.raw.Close()
// 		return nil, err
// 	}

// 	if err = r.setIptables(); err != nil {
// 		r.raw.Close()
// 		unix.Close(r.bindFd)
// 		return nil, err
// 	}

// 	return r, nil

// 	return
// }

// func (r *RawTCP) Read(b []byte) (n int, err error)
// func (r *RawTCP) Write(b []byte) (n int, err error)
// func (r *RawTCP) Close() error
// func (r *RawTCP) LocalAddr() Addr
// func (r *RawTCP) RemoteAddr() Addr
// func (r *RawTCP) SetDeadline(t time.Time) error
// func (r *RawTCP) SetReadDeadline(t time.Time) error
// func (r *RawTCP) SetWriteDeadline(t time.Time) error
